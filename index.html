<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title></title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
    
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/"></a></h1>
		<h2 class="header__subtitle"></h2>
	</header>

	<main>
		



	<article>
	
		<h1><a href="/2017/10/29/c-cpp-struct/">c-cpp-struct</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-10-29</span><br />
		
		
	</div>

	

	
		<h4 id="C和C-关于struct用法的不同"><a href="#C和C-关于struct用法的不同" class="headerlink" title="C和C++关于struct用法的不同"></a>C和C++关于struct用法的不同</h4><p>在C++中struct和class几乎没有区别，除了默认的类里面的变量或函数是public还是private的区别，到底哪个默认是public，我也懒得记了，每次写清楚就好了。</p>
<p>所以在C++中struct就看做是class好了。但是在struct，准确的叫法是结构体。<strong>结构体是一种把数据项组合在一起的数据结构。</strong></p>
<p>再来吐槽一下C/C++，C/C++的语法真的丑陋，语法让人产生多种理解，或难以理解与记忆。从stack overflow上相关问题的点赞数都可以看出来，大家对struct这个语法很不熟，这个语法就是比较丑陋，这个锅就应该C/C++背，谁TM叫你虐我千百遍。</p>
<p>（<a href="https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c/612350#612350）" target="_blank" rel="external">https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c/612350#612350）</a></p>
<p>关键字struct引入结构声明。结构声明是由花括号内的一系列声明组成。</p>
<p>struct声明定义了一种数据结构。在标志结构成员表结束的右花括号之后可以跟一个变量表，就像其他基本类型的变量声明一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;</div><div class="line">&#125; pt1, pt2;</div></pre></td></tr></table></figure>
<p>当然这样写一大堆东西比较麻烦，就有了一个叫做<strong>结构标记</strong>的东西，它是optional，放在struct关键字后面。<strong>结构标记</strong>就代表花括号内的声明，可以用它作为该声明的简写形式（K&amp;R C的原话）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以那句原话的意思就是，以后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p1</span>;</span></div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;</div><div class="line">&#125;p1;</div></pre></td></tr></table></figure>
<p>就是同一个意思。</p>
<p>当然，你在有结构标记这个可选项的同时，也可以声明变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;</div><div class="line">&#125;p1;</div></pre></td></tr></table></figure>
<p>这条语句就是把结构的声明和结构变量p1的声明合在一起了。</p>
<p>typedef也经常和struct用在一起。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;</div><div class="line">&#125; Point_type;</div></pre></td></tr></table></figure>
<p>这条语句因为有typedef，所以它是一个为某种类型引入一个新名字。我们读法就是把typedef去掉，然后按声明变量的读法读，只是这时候“变量名”不是变量了，而是某种类型的别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> y;</div><div class="line">&#125; Point_type;</div></pre></td></tr></table></figure>
<p>Pint_type才是“变量名”，Point是可选的<strong>结构标记</strong>。</p>
<p>以后你可以有两种方法来声明结构的变量了。一种是使用<strong>结构标记</strong>，一种是typedef引入的别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p1</span>;</span></div><div class="line">Point_type p2;</div></pre></td></tr></table></figure>
<p>情况1. 当你把上面的Point_type类型别名和Point<strong>结构标记</strong>写成同一个名字的时候，</p>
<p>情况2. 当你把结构标记和变量声明写成同一个名字的时候，</p>
<p>就可能发生confused。</p>
<p>例如：</p>
<p>情况1.引入了别名fruit和结构标记fruit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>&#123;</span></div><div class="line">  <span class="keyword">float</span> weight;</div><div class="line">  <span class="keyword">float</span> price_per_kg;</div><div class="line">&#125; fruit;</div></pre></td></tr></table></figure>
<p>情况2.引入了结构标记vegetable和声明了变量vegetable</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vegetable</span>&#123;</span></div><div class="line">  <span class="keyword">float</span> weight;</div><div class="line">  <span class="keyword">float</span> price_per_kg;</div><div class="line">&#125; vegetable;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> <span class="title">orange</span>;</span> <span class="comment">//使用结构标记fruit</span></div><div class="line">fruit orange; <span class="comment">//使用类型别名fruit</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vegetable</span> <span class="title">potato</span>;</span> <span class="comment">//使用结构标记vegetable</span></div><div class="line">vegetable potato; <span class="comment">// 错误！！！</span></div></pre></td></tr></table></figure>
<p>当有了C++时，confused进一步来了。</p>
<p>上面的情况2在C++中可以这样写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vegetable</span>&#123;</span></div><div class="line">  <span class="keyword">float</span> weight;</div><div class="line">  <span class="keyword">float</span> price_per_kg;</div><div class="line">&#125;;</div><div class="line">vegetable potato;</div></pre></td></tr></table></figure>
<p>这时候vegetable就不是一个结构标记了，就是一个类型了。所以可以使用类型名来声明一个对象potato了。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/10/29/cpp-complicated-declaration/">cpp-complicated-declaration</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-10-29</span><br />
		
		
	</div>

	

	
		<h3 id="C-C-复杂的变量声明"><a href="#C-C-复杂的变量声明" class="headerlink" title="C/C++ 复杂的变量声明"></a>C/C++ 复杂的变量声明</h3><h4 id="读懂它"><a href="#读懂它" class="headerlink" title="读懂它"></a>读懂它</h4><p>​    C/C++虐我千百遍，我待C++如戴颖洁。</p>
<p>​    C/C++最让我吐槽的地方，是它复杂的变量声明，变量声明可以说应该是最最最基础的东西，一个最最最基础的东西都这么复杂，这个确实不太合理，因为当你看代码，连一个声明都要看一半天，甚至拿着笔写一写来分析，会抓狂的。OK，吐槽完毕，最后当然是选择原谅C/C++啦。</p>
<p>​    变量声明就是声明一个符号，及其对应的类型，类型有基本的内置类型，还有像数组这种派生类型，当然还有自己定义的各种类类型。类型就是某种数据结构吧。</p>
<p>直接举例子来讲吧，下面这个声明是什么意思？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> * (*next) ();</div></pre></td></tr></table></figure>
<p>读懂复杂声明的方法：</p>
<p><strong>A 不管多复杂的变量声明，首先找到变量名。先不管const, volatile等关键字。</strong></p>
<p>这个声明的变量名是next。去掉const之后，声明变成：<figure class="highlight plain"><figcaption><span>* *(*next) ();```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**B 然后找到第一个基本内置类型，或类类型。**</div><div class="line"></div><div class="line">然后第一个基本内置类型是char，意思就是当变量next像声明那样写在表达式中的时候，其表示一个char类型的字符。</div><div class="line"></div><div class="line">即```* *(*next)()```在表达式中表示一个char字符。</div><div class="line"></div><div class="line">* **C 然后按照优先级的顺序反向拆解这个表达**</div><div class="line">  - **C. 1 括号的优先级第一**</div><div class="line">  - **C. 2 后缀操作符: 括号( )表示这是一个函数; 方括号[ ]表示这是一个数组**</div><div class="line">  - **C. 3 前缀操作符：星号*表示“指向...的指针”。**</div><div class="line"></div><div class="line">所以对```* *(*next)()```这个表达进行分解：</div><div class="line"></div><div class="line">1. ```* *(*next)()```表示一个char字符，所以</div><div class="line">2. ``` *(*next)()```就表示一个指针，指向char字符。</div><div class="line">3. ```(*next)()```就表示一个指针，指向一个char字符的指针。（即指针的指针）</div><div class="line">4. ```(*next)```就是一个函数，函数的参数为空，函数的返回值是一个指针的指针。（3所述）</div><div class="line">5. ```next```是一个指针，指向一个函数，这个函数的参数为空，返回值为一个指针的指针。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 网易的C++笔试题目</div><div class="line"></div><div class="line">再来说一下知乎上被大家吐槽的网易的C++笔试题目：</div><div class="line"></div><div class="line">https://www.zhihu.com/question/65116993</div><div class="line"></div><div class="line">a: int * ptr[n];</div><div class="line"></div><div class="line">b: int(*) ptr[n]; —&gt;  int (\*ptr)[n];</div><div class="line"></div><div class="line">c: int *ptr();</div><div class="line"></div><div class="line">d: int(*)ptr(); —&gt; int(\*ptr)();</div><div class="line"></div><div class="line">e: int( \*(  (\*ptr(int, int))  ) ) (int);</div><div class="line"></div><div class="line">abcde分别表示什么意思？</div><div class="line"></div><div class="line">**首先，没有(*)这种写法，所以b、d选项修改为后面的形式**</div><div class="line"></div><div class="line">按照上面的方法来分析，这些声明中都没有const关键字，所以这一步的分析就不需要了。</div><div class="line"></div><div class="line">* a:</div><div class="line"></div><div class="line">A: 变量名为ptr</div><div class="line"></div><div class="line">B: 基本内置类型为int</div><div class="line"></div><div class="line">C:  1. *ptr[n]表示一个intx型数字</div><div class="line"></div><div class="line">2. ptr[n]表示一个指针，指向int型数字</div><div class="line">3. ptr表示一个数组，数组的大小为n，数组中的元素为指向int型的指针。</div><div class="line"></div><div class="line">* b:</div><div class="line"></div><div class="line">A: 变量名为ptr</div><div class="line"></div><div class="line">B: 基本内置类型为int</div><div class="line"></div><div class="line">C: 1. (*ptr)[n]表示一个int型数字</div><div class="line"></div><div class="line">2. (*ptr)是一个数组，数组的大小为n，数组中的元素为int型数字。</div><div class="line">3. ptr是一个指针，指向数组，数组是这样的：数组的大小为n，数组中的元素为int型数字。</div><div class="line"></div><div class="line">* c:</div><div class="line"></div><div class="line">A: 变量名为ptr</div><div class="line"></div><div class="line">B: 基本内置类型为int</div><div class="line"></div><div class="line">C: 1. *ptr()表示一个int型数字</div><div class="line"></div><div class="line">2. ptr()表示一个指针，指向int型数字。</div><div class="line">3. ptr是一个函数，函数的参数为空，函数的返回值为一个指针，指向int型数字。</div><div class="line"></div><div class="line">* d:</div><div class="line"></div><div class="line">A: 变量名为ptr</div><div class="line"></div><div class="line">B: 基本内置类型为int</div><div class="line"></div><div class="line">C: 1. (*ptr)()表示一个int型数字</div><div class="line"></div><div class="line">2. (*ptr)是一个函数，函数的参数为空，函数的返回值是int型数字。</div><div class="line">3. ptr是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型数字</div><div class="line"></div><div class="line">* e: </div><div class="line"></div><div class="line">A: 变量名为ptr</div><div class="line"></div><div class="line">B: 基本内置类型为int</div><div class="line"></div><div class="line">C: 1. ( \*(  (\*ptr(int, int))  ) ) (int)表示一个int型数字</div><div class="line"></div><div class="line">2. \*(  (\*ptr(int, int))  ) 是一个函数，函数接收一个int型参数，返回一个int型</div><div class="line">3. (\*ptr(int, int))  是一个指针，指向一个函数，这个函数接收一个int型参数，返回值为int型</div><div class="line">4. ptr(int, int)是一个指针，指向另一个指针，这个指针（另一个指针）指向一个函数，这个函数接收一个int型参数，返回值为int型。</div><div class="line">5. ptr是一个函数，函数的参数为两个int型，返回值是一个指针，这个指针指向另一个指针，另一个指针指向一个函数，这个函数接收一个int型参数，返回值为int型。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">当然既然我吐槽这种写法，那么有什么办法避免这种写法了？答案是有的，typedef 和 using。</div><div class="line"></div><div class="line">#### 用typedef来简化复杂的声明</div><div class="line"></div><div class="line">摘要《C专家编程》里面的话来介绍typedef。</div><div class="line"></div><div class="line">​    typedef 是一种有趣的声明形式：**它为一种类型引入新的名字**，而不是为变量分配空间。在某些方面，typedef类似于宏文本替换——它并没有引入新类型，而是为现有类型取了个新名字，但它们之间存在一个关键的区别，容我稍后解释。</div><div class="line"></div><div class="line">​    如果现在回过头过去看看“声明是如何形成的”那一节，会发现typedef关键字可以是一个常规声明的一部分，可以出现在靠近声明开始部分的任何地方。事实上，typedef的格式与变量声明完全一样，只是多了typedef这个关键字，来向你提醒它的实质。</div><div class="line"></div><div class="line">​    由于typedef看上去跟变量声明完全一样，其实它们读起来也是一样的。分析复杂变量声明的方法同样适用于typedef。**普通声明表示“这个名字是一个指定类型的变量”，**而**typedef关键字并不创建一个变量，而是宣称“这个名字是指定类型的同一词”。**</div><div class="line"></div><div class="line">   举个例子来看看typedef是如何帮助阅读复杂的声明的。</div><div class="line"></div><div class="line">​    标准库中有一个函数，signal。它的声明如下</div><div class="line"></div><div class="line">```cpp</div><div class="line">void (*signal(int sig, void(*func)(int)))(int);</div></pre></td></tr></table></figure></p>
<p>我们也可以用前面介绍的方法来分析一下，这个声明是什么意思？</p>
<ul>
<li><p>A.:变量名为signal</p>
</li>
<li><p>B: 基本内置类型为void</p>
</li>
<li><p>C: </p>
<ul>
<li><ol>
<li><figure class="highlight plain"><figcaption><span>sig, void(*func)(int)))(int);```表示一个void型。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  - 2. 很明显```*signal(int sig, void(*func)(int))```是一个函数，函数的参数是一个int，返回值为void（没有返回值）。</div><div class="line">  - 3. ```signal(int sig, void(*func)(int))```是一个指针，指向一个函数，函数的参数是一个int，返回值为void。</div><div class="line">  - 4. ```signal(int, xxx)```是一个函数，函数的参数为一个int，一个xxx（待分析），返回值为一个指针，该指针指向一个函数，函数的参数是一个int，返回值为void。</div><div class="line">  - 5. 来分析xxx：void(func)(int)</div><div class="line">       - A. 变量名为func</div><div class="line">       - B. 基本类型为void</div><div class="line">       - C. 1. ``(*func)(int)``表示一个void型。</div><div class="line">         2. 很明显```*func```是一个函数，参数为一个int，返回值为空。</div><div class="line">         3. func是一个（函数）指针，指向一个函数，一个参数为一个int，返回值为空的函数。</div><div class="line"></div><div class="line">  连起来，这个声明声明了signal是一个函数，signal函数的参数有两个，一个是int，一个是一个函数指针，指向一个参数为int，返回值为空的函数；signal函数的返回值是一个指针，该指针指向一个函数（一个参数为int，返回值为空的函数）。</div><div class="line"></div><div class="line">好复杂，是不是？这个时候typedef就派上用场了。</div><div class="line"></div><div class="line">我们发现通用的部分：一个参数为int，返回值为void的函数。我们用typedef来简化。</div><div class="line"></div><div class="line">```cpp</div><div class="line">typedef void(*ptr_to_func)(int);</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>这个怎么读了？</p>
<p>首先有<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```cpp</div><div class="line">void(*ptr_to_func)(int)</div></pre></td></tr></table></figure></p>
<p>按照上面的分析方法：</p>
<p>ptr_to_func是一个（函数）指针，指向一个函数，函数的参数是int，返回值为void。</p>
<p>这样signal的声明就可以改写为下面的形式了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">ptr_to_func <span class="title">signal</span><span class="params">(<span class="keyword">int</span>, ptr_to_func)</span></span>;</div></pre></td></tr></table></figure>
<p>这样一看，就知道signal是一个函数，函数的参数有两个，一个是一个int，一个是一个ptr_to_func指针，返回值是一个ptr_to_func的指针。</p>
<h4 id="typedef-和宏文本替换的区别"><a href="#typedef-和宏文本替换的区别" class="headerlink" title="typedef 和宏文本替换的区别"></a>typedef 和宏文本替换的区别</h4><p>还是摘要一段《C专家编程》里面的话。</p>
<p>typedef和宏文本替换之间存在一个关键性的区别。正确看待这个区别的方法是把typedef看成是一种彻底的“封装”类型——在声明它之后不能再往里面增加别的东西。它和宏的区别主要tti体现在两个方面</p>
<ul>
<li>首先，可以用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不行。如下所示：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> peach int</span></div><div class="line"><span class="keyword">unsigned</span> peach i;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> banana;</div><div class="line"><span class="keyword">unsigned</span> banana i; <span class="comment">/*错误！ 非法的！*/</span></div></pre></td></tr></table></figure>
<ul>
<li>其次，在连续几个变量的声明中，用typedef定义的类型能够保证声明中所有的变量均为同一种类型，而用#define定义的类型则无法保证。如下所示：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> int_ptr int *;</span></div><div class="line">int_ptr chalk, cheese;</div></pre></td></tr></table></figure>
<p>宏其实只是简单的替换，所以替换之后，第二行变为了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> * chalk, cheese;</div></pre></td></tr></table></figure>
<p>所以其实是将chalk声明为一个指向int的指针，而cheese是一个int型。</p>
<p>相反，用typedef的代码，两个变量是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * char_ptr;</div><div class="line">char_ptr Bentley, Rolls_Royce;</div></pre></td></tr></table></figure>
<p>Bentley和Rolls_Royce的类型都是指向char的指针。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/10/29/extern-C/">extern-C</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-10-29</span><br />
		
		
	</div>

	

	
		<p>Problem: </p>
<p>In C++ source, what is the effect of extern “C”?</p>
<p>Real problem: In the project of dual camera bokeh, the api.h header file use the extern C.</p>
<p>Stack overflow: <a href="https://stackoverflow.com/questions/1041866/in-c-source-what-is-the-effect-of-extern-c/1041880#1041880" target="_blank" rel="external">https://stackoverflow.com/questions/1041866/in-c-source-what-is-the-effect-of-extern-c/1041880#1041880</a></p>
<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在用C++的项目源码中，经常会不可避免的会看到下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line"><span class="comment">/*...*/</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>它到底有什么用呢，你知道吗？而且这样的问题经常会出现在面试or笔试中。下面我就从以下几个方面来介绍它：</p>
<ul>
<li>1、#ifdef _cplusplus/#endif _cplusplus及发散</li>
<li>2、extern “C”<ul>
<li>2.1、extern关键字</li>
<li>2.2、”C”</li>
<li>2.3、小结extern “C”</li>
</ul>
</li>
<li>3、C和C++互相调用<ul>
<li>3.1、C++的编译和连接</li>
<li>3.2、C的编译和连接</li>
<li>3.3、C++中调用C的代码</li>
<li>3.4、C中调用C++的代码</li>
</ul>
</li>
<li>4、C和C++混合调用特别之处函数指针</li>
</ul>
<h4 id="1、-ifdef-cplusplus-endif-cplusplus及发散"><a href="#1、-ifdef-cplusplus-endif-cplusplus及发散" class="headerlink" title="1、#ifdef _cplusplus/#endif _cplusplus及发散"></a><strong>1、#ifdef _cplusplus/#endif _cplusplus及发散</strong></h4><p>在介绍extern “C”之前，我们来看下#ifdef _cplusplus/#endif _cplusplus的作用。很明显#ifdef/#endif、#ifndef/#endif用于条件编译，#ifdef _cplusplus/#endif _cplusplus——表示如果定义了宏_cplusplus，就执行#ifdef/#endif之间的语句，否则就不执行。</p>
<p>在这里为什么需要#ifdef _cplusplus/#endif _cplusplus呢？因为C语言中不支持extern “C”声明，如果你明白extern “C”的作用就知道在C中也没有必要这样做，这就是条件编译的作用！在.c文件中包含了extern “C”时会出现编译时错误。</p>
<p>既然说到了条件编译，我就介绍它的一个重要应用——<strong>避免重复包含头文件</strong>。还记得腾讯笔试就考过这个题目，给出类似下面的代码（下面是我最近在研究的一个开源web服务器——Mongoose的头文件mongoose.h中的一段代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MONGOOSE_HEADER_INCLUDED</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    MONGOOSE_HEADER_INCLUDED</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></div><div class="line"> </div><div class="line"><span class="comment">/*.................................</span></div><div class="line"><span class="comment"> * do something here</span></div><div class="line"><span class="comment"> *.................................</span></div><div class="line"><span class="comment"> */</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MONGOOSE_HEADER_INCLUDED */</span></span></div></pre></td></tr></table></figure>
<p>然后叫你说明上面宏#ifndef/#endif的作用？为了解释一个问题，我们先来看两个事实：</p>
<ul>
<li>这个头文件mongoose.h可能在项目中被多个源文件包含（#include “mongoose.h”），而对于一个大型项目来说，这些冗余可能导致错误，因为一个头文件包含类定义或inline函数，在一个源文件中mongoose.h可能会被#include两次（如，a.h头文件包含了mongoose.h，而在b.c文件中#include a.h和mongoose.h）——这就会出错（在同一个源文件中一个结构体、类等被定义了两次）。</li>
<li>从逻辑观点和减少编译时间上，都要求去除这些冗余。然而让程序员去分析和去掉这些冗余，不仅枯燥且不太实际，<strong>最重要的是有时候又需要这种冗余来保证各个模块的独立</strong>。</li>
</ul>
<p>为了解决这个问题，上面代码中的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MONGOOSE_HEADER_INCLUDED </span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    MONGOOSE_HEADER_INCLUDED </span></div><div class="line"></div><div class="line">/……………………………/ </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MONGOOSE_HEADER_INCLUDED */</span></span></div></pre></td></tr></table></figure>
<p>就起作用了。如果定义了MONGOOSE_HEADER_INCLUDED，#ifndef/#endif之间的内容就被忽略掉。因此，编译时第一次看到mongoose.h头文件，它的内容会被读取且给定MONGOOSE_HEADER_INCLUDED一个值。之后再次看到mongoose.h头文件时，MONGOOSE_HEADER_INCLUDED就已经定义了，mongoose.h的内容就不会再次被读取了。</p>
<h4 id="2、extern-“C”"><a href="#2、extern-“C”" class="headerlink" title="2、extern “C”"></a><strong>2、extern “C”</strong></h4><p>首先从字面上分析extern “C”，它由两部分组成——extern关键字、”C”。下面我就从这两个方面来解读extern “C”的含义。</p>
<h4 id="2-1、extern关键字"><a href="#2-1、extern关键字" class="headerlink" title="2.1、extern关键字"></a><strong>2.1、extern关键字</strong></h4><p>在一个项目中必须保证函数、变量、枚举等在所有的源文件中保持一致，除非你指定定义为局部的。首先来一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file1.c:</span></div><div class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">do</span> something here&#125;</div><div class="line"><span class="comment">//file2.c:</span></div><div class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;x=f();&#125;</div></pre></td></tr></table></figure>
<p>在file2.c中g()使用的x和f()是定义在file1.c中的。extern关键字表明file2.c中x，仅仅是一个变量的声明，其并不是在定义变量x，并未为x分配内存空间。变量x在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。但是可以声明多次，且声明必须保证类型一致，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file1.c:</span></div><div class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> b=<span class="number">1</span>;</div><div class="line">    <span class="keyword">extern</span> c;</div><div class="line"><span class="comment">//file2.c:</span></div><div class="line">    <span class="keyword">int</span> x;<span class="comment">// x equals to default of int type 0</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">extern</span> <span class="keyword">double</span> b;</div><div class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> c;</div></pre></td></tr></table></figure>
<p>在这段代码中存在着这样的三个错误：</p>
<ol>
<li>x被定义了两次</li>
<li>b两次被声明为不同的类型</li>
<li>c被声明了两次，但却没有定义</li>
</ol>
<p>回到extern关键字，extern是C/C++语言中表明<strong>函数</strong>和<strong>全局变量</strong>作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。</p>
<p>与extern对应的关键字是 static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。</p>
<h4 id="2-2、”C”"><a href="#2-2、”C”" class="headerlink" title="2.2、”C”"></a><strong>2.2、”C”</strong></h4><p>典型的，一个C++程序包含其它语言编写的部分代码。类似的，C++编写的代码片段可能被使用在其它语言编写的代码中。不同语言编写的代码互相调用是困难的，甚至是同一种编写的代码但不同的编译器编译的代码。例如，不同语言和同种语言的不同实现可能会在注册变量保持参数和参数在栈上的布局，这个方面不一样。</p>
<p>为了使它们遵守统一规则，可以使用extern指定一个编译和连接规约。例如，声明C和C++标准库函数strcyp()，并指定它应该根据C的编译和连接规约来链接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>*,<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</div></pre></td></tr></table></figure>
<p>注意它与下面的声明的不同之处：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>*,<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</div></pre></td></tr></table></figure>
<p>下面的这个声明仅表示在连接的时候调用strcpy()。</p>
<p>extern “C”指令非常有用，因为C和C++的近亲关系。<strong>注意：extern “C”指令中的C，表示的一种编译和连接规约，而不是一种语言。C表示符合C语言的编译和连接规约的任何语言，如Fortran、assembler等。</strong></p>
<p>还有要说明的是，extern “C”指令仅指定编译和连接规约，但不影响语义。例如在函数声明中，指定了extern “C”，仍然要遵守C++的类型检测、参数转换规则。</p>
<p>再看下面的一个例子，为了声明一个变量而不是定义一个变量，你必须在声明时指定extern关键字，但是当你又加上了”C”，它不会改变语义，但是会改变它的编译和连接方式。</p>
<p>如果你有很多语言要加上extern “C”，你可以将它们放到extern “C”{ }中。</p>
<h4 id="2-3、小结extern-“C”"><a href="#2-3、小结extern-“C”" class="headerlink" title="2.3、小结extern “C”"></a><strong>2.3、小结extern “C”</strong></h4><p>通过上面两节的分析，我们知道extern “C”的真实目的是实现<strong>类C和C++的混合编程</strong>。在C++源文件中的语句前面加上extern “C”，表明它按照类C的编译和连接规约来编译和连接，而不是C++的编译的连接规约。这样在类C的代码中就可以调用C++的函数or变量等。（注：我在这里所说的类C，代表的是跟C语言的编译和连接方式一致的所有语言）</p>
<h4 id="3、C和C-互相调用"><a href="#3、C和C-互相调用" class="headerlink" title="3、C和C++互相调用"></a><strong>3、C和C++互相调用</strong></h4><p>我们既然知道extern “C”是实现的类C和C++的混合编程。下面我们就分别介绍如何在C++中调用C的代码、C中调用C++的代码。首先要明白C和C++互相调用，你得知道它们之间的编译和连接差异，及如何利用extern “C”来实现相互调用。</p>
<h4 id="3-1、C-的编译和连接"><a href="#3-1、C-的编译和连接" class="headerlink" title="3.1、C++的编译和连接"></a><strong>3.1、C++的编译和连接</strong></h4><p>C++是一个面向对象语言（虽不是纯粹的面向对象语言），它支持函数的重载，重载这个特性给我们带来了很大的便利。为了支持函数重载的这个特性，C++编译器实际上将下面这些重载函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> f)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* s)</span></span>;</div></pre></td></tr></table></figure>
<p>编译为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_print_int</div><div class="line">_print_char</div><div class="line">_print_float</div><div class="line">_pirnt_string</div></pre></td></tr></table></figure>
<p>这样的函数名，来唯一标识每个函数。注：不同的编译器实现可能不一样，但是都是利用这种机制。所以当连接是调用print(3)时，它会去查找_print_int(3)这样的函数。下面说个题外话，正是因为这点，重载被认为不是多态，多态是运行时动态绑定（“一种接口多种实现”），如果硬要认为重载是多态，它顶多是编译时“多态”。</p>
<p>C++中的变量，编译也类似，如全局变量可能编译g_xx，类变量编译为c_xx等。连接是也是按照这种机制去查找相应的变量。</p>
<h4 id="3-2、C的编译和连接"><a href="#3-2、C的编译和连接" class="headerlink" title="3.2、C的编译和连接"></a><strong>3.2、C的编译和连接</strong></h4><p>C语言中并没有重载和类这些特性，故并不像C++那样print(int i)，会被编译为_print_int，而是直接编译为_print等。因此如果直接在C++中调用C的函数会失败，因为连接是调用C中的print(3)时，它会去找_print_int(3)。因此extern “C”的作用就体现出来了。</p>
<h4 id="3-3、C-中调用C的代码"><a href="#3-3、C-中调用C的代码" class="headerlink" title="3.3、C++中调用C的代码"></a><strong>3.3、C++中调用C的代码</strong></h4><p>什么叫C++中调用C的代码？例如，整个项目大部分是C++代码，但其中有一些函数是C编写的库，</p>
<p>如用C编写了一个数学库libmath.so, 其头文件为math.h。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//math.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MATH_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MATH_H</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//math.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> x+y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</div><div class="line">    result *= x;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//cpp_proj.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#incluse <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> a = add(<span class="number">2</span>, <span class="number">5</span>);</div><div class="line">  <span class="keyword">int</span> b = power(<span class="number">2</span>, <span class="number">5</span>);  </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"add(2, 5) is: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"power(2, 5) is: "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><figure class="figure"><img src="./extern-C/pictures/屏幕快照 2017-10-29 上午9.27.22.png" alt="屏幕快照 2017-10-29 上午9.27.22"><figcaption class="figure__caption">屏幕快照 2017-10-29 上午9.27.22</figcaption></figure></p>
<p>既然说是调用C，那么math.c肯定得用gcc来编译。用gcc编译math.c成动态库libmath.so，然后用nm来查看此库。发现_add 和 _power两个函数符号。</p>
<p>（nm的输出的意义，参考：<a href="http://www.cnblogs.com/itech/archive/2012/09/16/2687423.html）" target="_blank" rel="external">http://www.cnblogs.com/itech/archive/2012/09/16/2687423.html）</a></p>
<p>下面来编译cpp_proj.cpp:</p>
<p><figure class="figure"><img src="./extern-C/pictures/屏幕快照 2017-10-29 上午9.31.35.png" alt="屏幕快照 2017-10-29 上午9.31.35"><figcaption class="figure__caption">屏幕快照 2017-10-29 上午9.31.35</figcaption></figure></p>
<p>error: use of undeclared identifier ‘add’, ‘power’</p>
<p>这种错误就是连接错误，找不到add, power函数的定义。我们的add是我们自己定义的，这个函数不在默认库里面，所以我们要使用-l和-L参数来找到此函数。但是还是报同样的错误。所以问题就来了，为什么链接器找不到对应的函数了？我们明明给了对应的参数。</p>
<p>下面我们将cpp_proj.cpp改为如下形式，然后就编译通过了！</p>
<p><figure class="figure"><img src="./extern-C/pictures/屏幕快照 2017-10-29 上午9.36.56.png" alt="屏幕快照 2017-10-29 上午9.36.56"><figcaption class="figure__caption">屏幕快照 2017-10-29 上午9.36.56</figcaption></figure></p>
<p>为什么对cpp_proj.cpp加了extern “C”就可以了了？</p>
<p>我们将改之前，没有加extern “C”的文件命名为cpp_proj.c；改之后的，加了extern “C”的命名为cpp_proj_externC.cpp。然后将它们编译成.o文件，再链接。对编译之后的.o文件使用nm命令分析：</p>
<p>发现没有加extern “C”的cpp_proj.o的add和power两个函数被表示为了<strong>Z3addii 和 \</strong>Z5powerii；而加了extern “C”的cpp_proj_externC.o被表示为了_add 和 _power。</p>
<p>因为libmath.so是C语言的库，我们用nm也可以看出来，它的add和power两个函数的表示符号为_add 和 _power。所以cpp_proj_externC.cpp可以编译通过而cpp_proj.cpp无法编译通过，因为在C的库libmath.so中根本就找不到<strong>Z3addii 和 \</strong>Z5powerii这两个符号。</p>
<p><figure class="figure"><img src="./extern-C/pictures/Collage_Fotor.jpg" alt="Collage_Fotor"><figcaption class="figure__caption">Collage_Fotor</figcaption></figure></p>
<p><figure class="figure"><img src="./extern-C/pictures/屏幕快照 2017-10-29 上午9.42.09.png" alt="屏幕快照 2017-10-29 上午9.40.16"><figcaption class="figure__caption">屏幕快照 2017-10-29 上午9.40.16</figcaption></figure></p>
<p><strong>所以这就是extern C的作用，很简单，表示它后面的符号是用C的编译和链接的方法来进行。目的是为了能让C++和C混合使用</strong></p>
<h4 id="3-4、C中调用C-的代码"><a href="#3-4、C中调用C-的代码" class="headerlink" title="3.4、C中调用C++的代码"></a><strong>3.4、C中调用C++的代码</strong></h4><p>现在换成在C中调用C++的代码，这与在C++中调用C的代码<strong>形式有所不同</strong>，但是<strong>本质都是一样</strong>，都是为了混用，<strong>为了能找到对应的函数或变量符号</strong>。</p>
<p>形式有不同是因为：<code>extern &quot;C&quot;</code>在C中是语法错误。所以当在C项目中调用C++的代码，是需要对C++的头文件进行修改，即加上extern C修饰，并要重新编译C++的库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// cppExample.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPP_EXAMPLE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CPP_EXAMPLE_H</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// cppExample.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cppExample.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// cExample.c</span></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  add( <span class="number">2</span>, <span class="number">3</span> ); </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考文献：</p>
<p><a href="http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html</a></p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/09/26/expansion-quote-regex/">expansion-quote-regex</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-09-26</span><br />
		
		
	</div>

	

	
		<h4 id="Expansion"><a href="#Expansion" class="headerlink" title="Expansion:"></a>Expansion:</h4><p>Each time you type a command line and press the enter key, bash performs several processes upon the text before it carries out your command. We have seen a couple of cases of how a simple character sequence, for example “*”, can have a lot of meaning to the shell. The process that makes this happen is called expansion. With expansion, you type something and it is expanded into something else before the shell acts upon it.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> echo *</div><div class="line">Desktop Documents ls-output.txt Music Pictures Public Templates Videos</div></pre></td></tr></table></figure>
<p>More Expansion</p>
<p>pathname expansion: *</p>
<p>tilde character expansion: ~</p>
<p>arithmetic expansion: $((expression))</p>
<p>brace expansion: {a..z}, {1, 2, 3}, {A{1, 2}, B{3, 4}}</p>
<p>parameter expansion: $HOME</p>
<p>command substitution: $(command line), `command line`</p>
<h4 id="Quote"><a href="#Quote" class="headerlink" title="Quote:"></a>Quote:</h4><p>The shell provides a mechanism called quoting to selectively suppress unwanted expansions.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> echo The total is $100.00</div><div class="line">The total is 00.00</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> echo The total is \$100.00</div><div class="line">The total is 100.00</div></pre></td></tr></table></figure>
<p>More quote:</p>
<p>double quotes:</p>
<p>The first type of quoting we will look at is double quotes. If you place text inside double quotes, all the special characters used by the shell lose their special meaning and are treated as ordinary characters. The exceptions are $, \ (backslash), and ` (back-quote). This means that word-splitting, pathname expansion, tilde expansion, and brace expansion are suppressed, but parameter expansion, arithmetic expansion, and command substitution are still carried out.</p>
<p>single quotes:</p>
<p>If we need to suppress all expansions, we use single quotes. </p>
<p>escape character:</p>
<p>Sometimes we only want to quote a single character. To do this, we can precede a character with a backslash, which in this context is called the escape character. </p>
<h4 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression:"></a>Regular Expression:</h4><p>Simply put, regular expressions are symbolic notations used to identify patterns in text.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ls /usr/bin | grep zip</div></pre></td></tr></table></figure>
<p>While it may not seem apparent, our grep searches have been using regular expressions all along, albeit very simple ones. The regular expression “bzip” is taken to mean that a match will occur only if the line in the file contains at least four characters and that somewhere in the line the characters “b”, “z”, “i”, and “p” are found in that order, with no other characters in between. The characters in the string “bzip” are all literal characters, in that they match themselves. In addition to literals, regular expressions may also include metacharacters that are used to specify more complex matches. Regular expression metacharacters consist of the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^ $ . [ ] &#123; &#125; - ? * + ( ) | \</div></pre></td></tr></table></figure>
<blockquote>
<p>Note: As we can see, many of the regular expression metacharacters are also characters that have meaning to the shell when expansion is performed. When we pass regular expressions containing metacharacters on the command line, it is vital that they be enclosed in quotes to prevent the shell from attempting to expand them.</p>
</blockquote>
<p><strong>Added on 2017.10.24</strong></p>
<p>In above, it described the basic function of grep command, match the specific pattern. Sometimes, we want to extract the specific pattern. For example, recently I want to extract the frame_id from a string, the string looks like “test_1536x1088_wide_1.yuv”, “test1536_1088_wide2.yuv”,……”test1536_1088_wide56.yuv”….., what I want to do is extract the frame_id substring.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">prompt&gt;</span> var=test1536x1088_wide56.yuv</div><div class="line"></div><div class="line"><span class="meta">prompt&gt;</span> echo $var | grep -oE "wide.*" </div><div class="line"></div><div class="line"><span class="meta">prompt&gt;</span> wide_56.yuv</div><div class="line"></div><div class="line"><span class="meta">prompt&gt;</span> echo $var | grep -oE "wide.*" | grep -oE [0-9]+</div><div class="line"></div><div class="line"><span class="meta">prompt&gt;</span> 56</div></pre></td></tr></table></figure>
<p>Notes: -o means output the specific pattern</p>
<p>​             -E means extended regular expression; if you use metacharacters, you should use -E</p>
<p><strong>Remember: Expansion and Regex are different things!!!</strong></p>
<p>More Regular Expression Detail:</p>
<p><a href="https://github.com/HeGaoYuan/notes_of_python_for_everyone/blob/master/using_python_to_access_web_data/week2/regular_expression.ipynb" target="_blank" rel="external">https://github.com/HeGaoYuan/notes_of_python_for_everyone/blob/master/using_python_to_access_web_data/week2/regular_expression.ipynb</a></p>
<p>Reference: </p>
<p><a href="https://billie66.github.io/TLCL/book/chap08.html" target="_blank" rel="external">https://billie66.github.io/TLCL/book/chap08.html</a></p>
<p><a href="https://billie66.github.io/TLCL/book/chap20.html" target="_blank" rel="external">https://billie66.github.io/TLCL/book/chap20.html</a></p>
<p><a href="https://github.com/HeGaoYuan/notes_of_python_for_everyone/blob/master/using_python_to_access_web_data/week2/regular_expression.ipynb" target="_blank" rel="external">https://github.com/HeGaoYuan/notes_of_python_for_everyone/blob/master/using_python_to_access_web_data/week2/regular_expression.ipynb</a></p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/08/29/goal/">goal</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-08-29</span><br />
		
		
	</div>

	

	
		<p>1.Caffe</p>
<p>2.OpenCV source code</p>
<p>3.cpp_concurrency_in_action</p>
<p>4.Linux TLCL</p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/08/29/opencv-image-GeoTrans/">opencv-image-GeoTrans</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-08-29</span><br />
		
		
	</div>

	

	
		<h3 id="图像的几何变换"><a href="#图像的几何变换" class="headerlink" title="图像的几何变换"></a>图像的几何变换</h3><p>图像的几何变换是在不改变图像内容的前提下对图像像素的进行空间几何变换</p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/08/25/Using-OpenCV-to-Learn-CPP/">Using-OpenCV-to-Learn-CPP</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-08-25</span><br />
		
		
	</div>

	

	
		<p>最近想完成一个心愿，就是写一下通过学习研究OpneCV的源码来学习C++。</p>
<p>我们首先来研究两个最简单的类Point<em>和 Rect\</em>类的源码，然后进阶学习Mat类的源码。通过研究这些类的源码，来了解C++的一些语言特性，一来可以熟悉C++（C++需要不断练习）；二来可以学习类设计的精华，以便自己以后再设计一个类的时候应该怎么写。</p>
<p><strong>我们第一个要研究的类是Point_，它是一个2维空间的Point模板类。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="class"><span class="keyword">class</span> <span class="title">Point_</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  <span class="comment">//各种构造函数</span></div><div class="line">  Point_(); <span class="comment">//默认构造函数</span></div><div class="line">  Point_(_Tp x, _Tp y); <span class="comment">//常见的通过两个点的构造函数</span></div><div class="line">  Point_(<span class="keyword">const</span> Point_&amp; pt); <span class="comment">//拷贝构造函数</span></div><div class="line">  Point_(<span class="keyword">const</span> CvPoint&amp; pt); <span class="comment">//类型转换构造函数1</span></div><div class="line">  Point_(<span class="keyword">const</span> CvPoint2D32f&amp; pt); <span class="comment">//类型转换构造函数2</span></div><div class="line">  Point_(<span class="keyword">const</span> Size_&lt;Tp&gt;&amp; sz);  <span class="comment">//类型转换构造函数3</span></div><div class="line">  Point_(<span class="keyword">const</span> Vec_&lt;Tp, <span class="number">2</span>&gt;&amp; v);  <span class="comment">//类型转换构造函数4</span></div><div class="line">  </div><div class="line">  _Tp x, y; <span class="comment">//2维空间点的两个坐标</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="一个类最先要实现的肯定是各种各样的构造函数啦。"><a href="#一个类最先要实现的肯定是各种各样的构造函数啦。" class="headerlink" title="一个类最先要实现的肯定是各种各样的构造函数啦。"></a>一个类最先要实现的肯定是各种各样的构造函数啦。</h4><p>构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。</p>
<p>1.默认的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point() : x(<span class="number">0</span>), y(<span class="number">0</span>)&#123;&#125;</div></pre></td></tr></table></figure>
<p>2.常见的通过两个点的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(_Tp _x, _Tp _y) : x(_x), y(_y)&#123;&#125;</div></pre></td></tr></table></figure>
<p>3.拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> Point_&amp; pt) : x(pt.x), y(pt.y)&#123;&#125;</div></pre></td></tr></table></figure>
<p>4.只有一个参数的构造函数</p>
<p>只有一个参数的构造函数在C++中也可以称作为<strong>类型转换构造函数</strong>，它可以将一个指定类型的数据（也就是这种构造函数的唯一参数类型）转换为类的对象。另一种说法：<strong>按照默认规定，只有一个参数的构造函数也定义了一个隐式转换，将该构造函数对应数据类型转换为该类对象</strong>。</p>
<ol>
<li><p>当这种<strong>类型转换构造函数</strong>没有声明为explicit的时候，它既可以进行显示的类型转换也可以进行隐式的类型转换。下面看看隐式类型转换的例子。</p>
<p>这又和另外一个C++的概念有关，直接初始化和复制初始化，</p>
<p>下面这两句代码可以看做直接初始化和复制初始化两种不同的初始化方式。但是第二句代码既可以看做是MyString对象str2的复制初始化，也可以看做是一个隐式的类型转换，即将一个C风格的字符串转化为了MyString对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"hgy love dyj!"</span>)</span></span>;</div><div class="line">MyString str2 = <span class="string">"dyj love hgy!"</span>;</div></pre></td></tr></table></figure>
<p>另外的例子：</p>
<p>第二句代码既可以看做复制初始化也可以看做是隐式的将int型（5的类型）转化为了MyComplex类型。还有在非初始化的时候进行的类型转换，第4句代码（没有歧义的前提下）就会隐式的先把5.5转换为一个临时的无名MyComplex类型，然后再对两个MyComplex类型进行相加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">MyComplex <span class="title">com1</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line">MyComplex com2 = <span class="number">5</span>;</div><div class="line"></div><div class="line">MyComplex com(10, 10), sum;</div><div class="line">sum = com + <span class="number">5.5</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>当这种<strong>类型转换构造函数</strong>声明成了explict的时候，那它只能进行显示的类型转换了，而不能进行隐式的类型转换。上面的代码：</p>
<p>第一句直接初始化依然有效。</p>
<p>第二句复制初始化，也可以看做隐式类型转换，编译不通过。</p>
<p>第四句牵涉隐式类型转换，编译不通过。</p>
</li>
</ol>
<p><strong>类型转换构造函数</strong>可以将一个指定类型的数据转换为类的对象。但是不能反过来将一个类的对象转换为一个其他类型的数据(例如将一个Complex类对象转换成double类型数据)。C++提供<strong>类型转换函数(type conversion function)</strong>来解决这个问题，类型转换函数的作用是将一个类的对象转换成另一类型的数据，它是一个以operator开头的成员函数，我们到时候会介绍。</p>
<p>上面就是关于只有一个参数的构造函数的知识点的介绍，下面就看下相关的源码：</p>
<ul>
<li><p>类型转换构造函数1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> CvPoint&amp; pt) : x((_Tp)pt.x), y((_Tp)pt.y)&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类型转换构造函数2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> CvPoint2D32f&amp; pt) : x(saturate_cast&lt;_Tp&gt;(pt.x)), y(saturate_cast&lt;_Tp&gt;(pt.y))&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类型转换构造函数3</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz) : x(sz.width), y(sz.height)&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类型转换构造函数4</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> Vec&lt;_Tp, <span class="number">2</span>&gt;&amp; v) : x(v[<span class="number">0</span>]), y(v[<span class="number">1</span>])&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="然后我们来实现【类型转换构造函数】对应的【类型转换函数】"><a href="#然后我们来实现【类型转换构造函数】对应的【类型转换函数】" class="headerlink" title="然后我们来实现【类型转换构造函数】对应的【类型转换函数】"></a>然后我们来实现【类型转换构造函数】对应的【类型转换函数】</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="class"><span class="keyword">class</span> <span class="title">Point_</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  <span class="comment">//类型转换构造函数</span></div><div class="line">  Point_(<span class="keyword">const</span> CvPoint&amp; pt); <span class="comment">//类型转换构造函数1</span></div><div class="line">  Point_(<span class="keyword">const</span> CvPoint2D32f&amp; pt); <span class="comment">//类型转换构造函数2</span></div><div class="line">  Point_(<span class="keyword">const</span> Size_&lt;Tp&gt;&amp; sz);  <span class="comment">//类型转换构造函数3</span></div><div class="line">  Point_(<span class="keyword">const</span> Vec_&lt;Tp, <span class="number">2</span>&gt;&amp; v);  <span class="comment">//类型转换构造函数4</span></div><div class="line">  </div><div class="line">  <span class="comment">//类型转换函数</span></div><div class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//类型转换函数1</span></div><div class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint2D32f</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//类型转换函数2</span></div><div class="line">  <span class="keyword">operator</span> Vec&lt;_Tp, <span class="number">2</span>&gt;() <span class="keyword">const</span>; <span class="comment">//类型转换函数4</span></div><div class="line">  </div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Point_&lt;_Tp2&gt;() <span class="keyword">const</span>; </div><div class="line">  </div><div class="line">  _Tp x, y; <span class="comment">//2维空间点的两个坐标</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类型转换函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rect_</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  </div><div class="line">  <span class="comment">//! 各种各样的构造函数</span></div><div class="line">  Rect_(); <span class="comment">//默认构造函数</span></div><div class="line">  Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height); <span class="comment">//常用的构造函数，使用4个值来进行构造，分别代表矩形左上角的坐标x、y，以及矩形的宽和高。</span></div><div class="line">  Rect_(<span class="keyword">const</span> Rect_&amp; r); <span class="comment">//常用的构造函数，使用一个Rect_对象来进行构造</span></div><div class="line">  Rect_(<span class="keyword">const</span> CvRect&amp; r); <span class="comment">//使用一个CvRect对象来进行构造(旧的OpenCV1.0中的矩形类)</span></div><div class="line">  Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; org, <span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz);</div><div class="line">  Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt1, <span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt2);</div><div class="line">  </div><div class="line">  _Tp x, y, width, height;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _TP&gt; <span class="keyword">inline</span> Rect_&lt;_Tp&gt;::Rect_() : x(<span class="number">0</span>), y(<span class="number">0</span>), width(<span class="number">0</span>), height(<span class="number">0</span>)&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Rect_&lt;_Tp&gt;::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height)&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Rect_&lt;_Tp&gt;::Rect_(<span class="keyword">const</span> Rect_&lt;_Tp&gt;&amp; r) : x(r.x), y(r.y), width(r.width), height(r.height)&#123;&#125;</div></pre></td></tr></table></figure>

	

	

</article>




	<article>
	
		<h1><a href="/2017/08/24/linux-I-O-redirection/">linux-I/O-redirection</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-08-24</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/linux/">linux</a>
			</span>
		
	</div>

	

	
		<p>In this lesson we are going to unleash what may be the coolest feature of the command line. It’s called I/O redirection. The “I/O” stands for input/output and with this facility you can redirect the input and output of commands to and from files.</p>
<h3 id="redirection-standard-output"><a href="#redirection-standard-output" class="headerlink" title="redirection standard output"></a>redirection standard output</h3><p> To redirect standard output to another file besides the screen, we use the “&gt;” redirection operator followed by the name of the file. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls /usr/local/lib &gt; local_lib.txt</div></pre></td></tr></table></figure>
<p>When we redirect output with the “&gt;” redirection operator, the destination file is always rewritten from the beginning. So, how can we append redirected output to a file instead of overwriting the file from the beginning? For that, we use the “&gt;&gt;” redirection operator, like so:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls /usr/local/lib &gt;&gt; local_lib.txt</div></pre></td></tr></table></figure>
<p>Using the “&gt;&gt;” operator will result in the output being appended to the file. If the file does not already exist, it is created just as though the “&gt;” operator had been used.</p>
<h3 id="redirection-standard-error"><a href="#redirection-standard-error" class="headerlink" title="redirection standard error"></a>redirection standard error</h3><p> To redirect standard error to another file besides the screen, we use the “2&gt;”  followed by the name of the file. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls /myusr/<span class="built_in">local</span>/lib 2&gt; ls_error_message.txt</div></pre></td></tr></table></figure>
<h3 id="redirection-standard-output-and-error-to-a-same-file"><a href="#redirection-standard-output-and-error-to-a-same-file" class="headerlink" title="redirection standard output and error to a same file"></a>redirection standard output and error to a same file</h3><p> To redirect standard output and standard error to a same file, we use the “&amp;&gt;”  followed by the name of the file. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls /myusr/local/lib &amp;&gt; error_and_output.txt</div></pre></td></tr></table></figure>
<h3 id="summarize"><a href="#summarize" class="headerlink" title="summarize"></a>summarize</h3><p>just remember four different output redirection “operator” </p>
<p>> , >&gt;, 2&gt;, &amp;&gt; </p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://billie66.github.io/TLCL/book/chap07.html" target="_blank" rel="external">http://billie66.github.io/TLCL/book/chap07.html</a></p>

	

	

</article>




	<article>
	
		<h1><a href="/2017/07/30/hello-world/">Hello World</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-07-30</span><br />
		
		
	</div>

	

	
		<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

	

	

</article>






	<span class="different-posts">📕 end of posts 📕</span>


	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2017 John Doe | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
