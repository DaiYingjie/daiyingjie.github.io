<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>Using-OpenCV-to-Learn-CPP | </title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
    
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/"></a></h1>
		<h2 class="header__subtitle"></h2>
	</header>

	<main>
		<article>
	
		<h1>Using-OpenCV-to-Learn-CPP</h1>
	
	<div class="article__infos">
		<span class="article__date">2017-08-25</span><br />
		
		
	</div>

	

	
		<p>最近想完成一个心愿，就是写一下通过学习研究OpneCV的源码来学习C++。</p>
<p>我们首先来研究两个最简单的类Point<em>和 Rect\</em>类的源码，然后进阶学习Mat类的源码。通过研究这些类的源码，来了解C++的一些语言特性，一来可以熟悉C++（C++需要不断练习）；二来可以学习类设计的精华，以便自己以后再设计一个类的时候应该怎么写。</p>
<p><strong>我们第一个要研究的类是Point_，它是一个2维空间的Point模板类。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="class"><span class="keyword">class</span> <span class="title">Point_</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  <span class="comment">//各种构造函数</span></div><div class="line">  Point_(); <span class="comment">//默认构造函数</span></div><div class="line">  Point_(_Tp x, _Tp y); <span class="comment">//常见的通过两个点的构造函数</span></div><div class="line">  Point_(<span class="keyword">const</span> Point_&amp; pt); <span class="comment">//拷贝构造函数</span></div><div class="line">  Point_(<span class="keyword">const</span> CvPoint&amp; pt); <span class="comment">//类型转换构造函数1</span></div><div class="line">  Point_(<span class="keyword">const</span> CvPoint2D32f&amp; pt); <span class="comment">//类型转换构造函数2</span></div><div class="line">  Point_(<span class="keyword">const</span> Size_&lt;Tp&gt;&amp; sz);  <span class="comment">//类型转换构造函数3</span></div><div class="line">  Point_(<span class="keyword">const</span> Vec_&lt;Tp, <span class="number">2</span>&gt;&amp; v);  <span class="comment">//类型转换构造函数4</span></div><div class="line">  </div><div class="line">  _Tp x, y; <span class="comment">//2维空间点的两个坐标</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="一个类最先要实现的肯定是各种各样的构造函数啦。"><a href="#一个类最先要实现的肯定是各种各样的构造函数啦。" class="headerlink" title="一个类最先要实现的肯定是各种各样的构造函数啦。"></a>一个类最先要实现的肯定是各种各样的构造函数啦。</h4><p>构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。</p>
<p>1.默认的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point() : x(<span class="number">0</span>), y(<span class="number">0</span>)&#123;&#125;</div></pre></td></tr></table></figure>
<p>2.常见的通过两个点的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(_Tp _x, _Tp _y) : x(_x), y(_y)&#123;&#125;</div></pre></td></tr></table></figure>
<p>3.拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> Point_&amp; pt) : x(pt.x), y(pt.y)&#123;&#125;</div></pre></td></tr></table></figure>
<p>4.只有一个参数的构造函数</p>
<p>只有一个参数的构造函数在C++中也可以称作为<strong>类型转换构造函数</strong>，它可以将一个指定类型的数据（也就是这种构造函数的唯一参数类型）转换为类的对象。另一种说法：<strong>按照默认规定，只有一个参数的构造函数也定义了一个隐式转换，将该构造函数对应数据类型转换为该类对象</strong>。</p>
<ol>
<li><p>当这种<strong>类型转换构造函数</strong>没有声明为explicit的时候，它既可以进行显示的类型转换也可以进行隐式的类型转换。下面看看隐式类型转换的例子。</p>
<p>这又和另外一个C++的概念有关，直接初始化和复制初始化，</p>
<p>下面这两句代码可以看做直接初始化和复制初始化两种不同的初始化方式。但是第二句代码既可以看做是MyString对象str2的复制初始化，也可以看做是一个隐式的类型转换，即将一个C风格的字符串转化为了MyString对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"hgy love dyj!"</span>)</span></span>;</div><div class="line">MyString str2 = <span class="string">"dyj love hgy!"</span>;</div></pre></td></tr></table></figure>
<p>另外的例子：</p>
<p>第二句代码既可以看做复制初始化也可以看做是隐式的将int型（5的类型）转化为了MyComplex类型。还有在非初始化的时候进行的类型转换，第4句代码（没有歧义的前提下）就会隐式的先把5.5转换为一个临时的无名MyComplex类型，然后再对两个MyComplex类型进行相加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">MyComplex <span class="title">com1</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line">MyComplex com2 = <span class="number">5</span>;</div><div class="line"></div><div class="line">MyComplex com(10, 10), sum;</div><div class="line">sum = com + <span class="number">5.5</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>当这种<strong>类型转换构造函数</strong>声明成了explict的时候，那它只能进行显示的类型转换了，而不能进行隐式的类型转换。上面的代码：</p>
<p>第一句直接初始化依然有效。</p>
<p>第二句复制初始化，也可以看做隐式类型转换，编译不通过。</p>
<p>第四句牵涉隐式类型转换，编译不通过。</p>
</li>
</ol>
<p><strong>类型转换构造函数</strong>可以将一个指定类型的数据转换为类的对象。但是不能反过来将一个类的对象转换为一个其他类型的数据(例如将一个Complex类对象转换成double类型数据)。C++提供<strong>类型转换函数(type conversion function)</strong>来解决这个问题，类型转换函数的作用是将一个类的对象转换成另一类型的数据，它是一个以operator开头的成员函数，我们到时候会介绍。</p>
<p>上面就是关于只有一个参数的构造函数的知识点的介绍，下面就看下相关的源码：</p>
<ul>
<li><p>类型转换构造函数1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> CvPoint&amp; pt) : x((_Tp)pt.x), y((_Tp)pt.y)&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类型转换构造函数2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> CvPoint2D32f&amp; pt) : x(saturate_cast&lt;_Tp&gt;(pt.x)), y(saturate_cast&lt;_Tp&gt;(pt.y))&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类型转换构造函数3</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz) : x(sz.width), y(sz.height)&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类型转换构造函数4</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Point_&lt;_Tp&gt;::Point(<span class="keyword">const</span> Vec&lt;_Tp, <span class="number">2</span>&gt;&amp; v) : x(v[<span class="number">0</span>]), y(v[<span class="number">1</span>])&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="然后我们来实现【类型转换构造函数】对应的【类型转换函数】"><a href="#然后我们来实现【类型转换构造函数】对应的【类型转换函数】" class="headerlink" title="然后我们来实现【类型转换构造函数】对应的【类型转换函数】"></a>然后我们来实现【类型转换构造函数】对应的【类型转换函数】</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="class"><span class="keyword">class</span> <span class="title">Point_</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  <span class="comment">//类型转换构造函数</span></div><div class="line">  Point_(<span class="keyword">const</span> CvPoint&amp; pt); <span class="comment">//类型转换构造函数1</span></div><div class="line">  Point_(<span class="keyword">const</span> CvPoint2D32f&amp; pt); <span class="comment">//类型转换构造函数2</span></div><div class="line">  Point_(<span class="keyword">const</span> Size_&lt;Tp&gt;&amp; sz);  <span class="comment">//类型转换构造函数3</span></div><div class="line">  Point_(<span class="keyword">const</span> Vec_&lt;Tp, <span class="number">2</span>&gt;&amp; v);  <span class="comment">//类型转换构造函数4</span></div><div class="line">  </div><div class="line">  <span class="comment">//类型转换函数</span></div><div class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//类型转换函数1</span></div><div class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">CvPoint2D32f</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//类型转换函数2</span></div><div class="line">  <span class="keyword">operator</span> Vec&lt;_Tp, <span class="number">2</span>&gt;() <span class="keyword">const</span>; <span class="comment">//类型转换函数4</span></div><div class="line">  </div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp2&gt; <span class="keyword">operator</span> Point_&lt;_Tp2&gt;() <span class="keyword">const</span>; </div><div class="line">  </div><div class="line">  _Tp x, y; <span class="comment">//2维空间点的两个坐标</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类型转换函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rect_</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> _Tp value_type;</div><div class="line">  </div><div class="line">  <span class="comment">//! 各种各样的构造函数</span></div><div class="line">  Rect_(); <span class="comment">//默认构造函数</span></div><div class="line">  Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height); <span class="comment">//常用的构造函数，使用4个值来进行构造，分别代表矩形左上角的坐标x、y，以及矩形的宽和高。</span></div><div class="line">  Rect_(<span class="keyword">const</span> Rect_&amp; r); <span class="comment">//常用的构造函数，使用一个Rect_对象来进行构造</span></div><div class="line">  Rect_(<span class="keyword">const</span> CvRect&amp; r); <span class="comment">//使用一个CvRect对象来进行构造(旧的OpenCV1.0中的矩形类)</span></div><div class="line">  Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; org, <span class="keyword">const</span> Size_&lt;_Tp&gt;&amp; sz);</div><div class="line">  Rect_(<span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt1, <span class="keyword">const</span> Point_&lt;_Tp&gt;&amp; pt2);</div><div class="line">  </div><div class="line">  _Tp x, y, width, height;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _TP&gt; <span class="keyword">inline</span> Rect_&lt;_Tp&gt;::Rect_() : x(<span class="number">0</span>), y(<span class="number">0</span>), width(<span class="number">0</span>), height(<span class="number">0</span>)&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Rect_&lt;_Tp&gt;::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height)&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span> Rect_&lt;_Tp&gt;::Rect_(<span class="keyword">const</span> Rect_&lt;_Tp&gt;&amp; r) : x(r.x), y(r.y), width(r.width), height(r.height)&#123;&#125;</div></pre></td></tr></table></figure>

	

	
		<span class="different-posts"><a href="/2017/08/25/Using-OpenCV-to-Learn-CPP/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2017 John Doe | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
